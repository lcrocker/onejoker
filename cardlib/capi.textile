---
layout: cardlib
title: "CardLib C API"
---

h1. Using the library in your C code

h2. Basics

CardLib represents cards as small integers, in the following order (for why I chose this representation, see ["Representing playing cards in software":http://etceterology.com/blog/2013/5/23/representing-playing-cards-in-software]):

{% highlight cpp %}
    "2c" =  1      "6c" = 17      "Tc" = 33      "Ac" = 49
    "2d" =  2      "6d" = 18      "Td" = 34      "Ad" = 50
    "2h" =  3      "6h" = 19      "Th" = 35      "Ah" = 51
    "2s" =  4      "6s" = 20      "Ts" = 36      "As" = 52
    "3c" =  5      "7c" = 21      "Jc" = 37
    "3d" =  6      "7d" = 22      "Jd" = 38      "JK" = 53
    "3h" =  7      "7h" = 23      "Jh" = 39      "JR" = 54
    "3s" =  8      "7s" = 24      "Js" = 40
    "4c" =  9      "8c" = 25      "Qc" = 41
    "4d" = 10      "8d" = 26      "Qd" = 42
    "4h" = 11      "8h" = 27      "Qh" = 43
    "4s" = 12      "8s" = 28      "Qs" = 44
    "5c" = 13      "9c" = 29      "Kc" = 45
    "5d" = 14      "9d" = 30      "Kd" = 46
    "5h" = 15      "9h" = 31      "Kh" = 47
    "5s" = 16      "9s" = 32      "Ks" = 48
{% endhighlight %}

Functions and macros of the library begin with @oj@ (@OJ@ for macros), often with a third letter further clarifying the use of the function or macro. Here, for example, are the defines for basic card values, ranks, and suits:

{% highlight cpp %}
    Ranks:          Suits:          Cards:

    OJR_DEUCE       OJS_CLUB        OJ_JOKER
    OJR_TWO         OJS_DIAMOND     OJ_BLACKJOKER
    OJR_TREY        OJS_HEART       OJ_REDJOKER
    OJR_THREE       OJS_SPADE
    OJR_FOUR
    OJR_FIVE
    OJR_SIX         Macros:
    OJR_SEVEN
    OJR_EIGHT       OJ_RANK(c)
    OJR_NINE        OJ_SUIT(c)
    OJR_TEN         OJ_CARD(r,s)
    OJR_JACK
    OJR_QUEEN
    OJR_KING
    OJR_ACE
    OJR_JOKER
{% endhighlight %}

The macros can be used to convert between card values and ranks and suits. For example, given a card value (one of the integers above) of @c@,

{% highlight cpp %}
    OJ_RANK(c) == OJR_QUEEN             // Is the card a queen?
    OJ_RANK(c) < OJR_TEN                // Is the card 2 through 9?
    OJ_SUIT(c) == OJS_DIAMOND           // Is the card a diamond?
    OJ_RANK(c) == OJR_JOKER             // Is card (either) joker?
    c == OJ_JOKER                       // Is card black joker?

    c = OJ_CARD(OJR_NINE, OJS_SPADE)    // c is now 32 (9 of spades)
{% endhighlight %}

Note that there is both an @OJR_JOKER@, which is the _rank_ of both jokers, and an @OJ_JOKER@, which is the card value of the single (or black) joker. Note also that because card values are ordered the way they are, you can often compare ranks without having to calculate @OJ_RANK()@ at all. For example:

{% highlight cpp %}
    c < OJ_CARD(OJR_TEN, OJS_CLUB)      // Is card < 10?
    c >= OJ_CARD(OJR_ACE, OJS_CLUB)     // Is card ace (or joker)?
{% endhighlight %}

h2. Text functions

Functions that handle input and output of cards as text begin with @ojt_@. They are:

h3. @char *ojt_card(int c)@

Given the integer value of a card, returns a pointer to a constant 2-character string representing that card. So, for example, @ojt_card(OJ_CARD(OJR_SEVEN, OJS_HEART))@ returns @"7h"@.

h3. @char *ojt_rank(int c)@

Gives the rank name of the card in text, e.g., "Deuce", "Jack", etc.

h3. @char *ojt_suit(int c)@

Gives the suit name of the card, e.g., "Diamond", "Spade".

h3. @char *ojt_fullname(int c, char *buf, int size)@

Fills the given buffer with text like "King of clubs", etc.

h3. @int ojt_val(char *str)@

Returns the integer card value corresponding to the passed string. E.g., @ojt_val("6c")@ returns 17.

h3. @int ojt_vals(char *str, int *arr, int size)@

Fills the given array with card values corresponding to the passed string, which contains multiple cards. E.g., @ojt_vals("As Th 3d")@ will fill the first three positions of the given array with 52, 35, 6. Returns the number of cards actually converted.

h2. Card lists

Most of the action of a card game or simulation will involve dealing with sequences of cards: decks, hands, discard piles, and so on. CardLib uses @oj_cardlist_t@ to represent these. Each such list structure also contains a pointer to the actual list of cards it represents, which is an integer array that must be allocated separately. Here is some basic code that allocates two lists for a deck and a hand, deals some cards, and prints the hand:

{% highlight cpp %}
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "ojcardlib.h"

int main(int argc, char *argv[]) {
    int i, db[52], hb[5];
    char text[20];
    oj_cardlist_t deck, hand;

    ojl_new(&deck, db, 52);
    ojl_fill(&deck, 52, OJD_STANDARD);
    ojl_shuffle(&deck);

    ojl_new(&hand, hb, 5);
    for (i = 0; i < 5; ++i) ojl_append(&hand, ojl_pop(&deck));

    ojl_text(&hand, text, sizeof(text));
    printf("%s\n", text);

    return 0;
}
{% endhighlight %}

List-handling functions begin with @ojl_@. They generally return integers that are either specific to the function, or just 0 to indicate success. On failure, they return negative integers to indicate the type of error:

{% highlight cpp %}
    OJE_NOTFOUND        // The information sought was not present
    OJE_RDONLY          // You have attempted to change a protected list
    OJE_FULL            // You tried to add to a list that's already full
    OJE_DUPLICATE       // You tried to add a card already present in a list
                        //     that's flagged OJF_UNIQUE
    OJE_BADINDEX        // You have given an out-of-bounds index
{% endhighlight %}

h3. @int ojl_new(oj_cardlist_t *sp, int *buf, int size)@

Initializes a new card list structure with the given integer array. The passed buffer must be large enough to contain @size@ integers. The list will never contain more than @size@ cards. It will be initially empty.

h3. @int ojl_pflag(oj_cardlist_t *sp, int mask)@<br>@int ojl_set_pflag(oj_cardlist_t *sp, int mask)@

Gets and sets one of the permanent flags associated with this list object. There are two important flags to note:

{% highlight cpp %}
    OJF_RDONLY      // This list cannot be modified
    OJF_UNIQUE      // This list may not contain duplicates
{% endhighlight %}

If one of these flags is set, any attempt to violate the given constraint will produce an error. Furthermore, lists marked as unique have special properties: such lists will compare equal if they contain the same cards in different order, and will hash equal.

h3. @int ojl_truncate(oj_cardlist_t *sp, int size)@<br>@int ojl_clear(oj_cardlist_t *sp)@

Truncate the list to the given size (0 for @_clear@). Truncate will have no effect (but produce no error) if the list is already smaller than the given size. Returns the final size of the list.

h3. @int ojl_size(oj_cardlist_t *sp)@

Returns the current size of the list.

h3. @uint32_t ojl_hash(oj_cardlist_t *sp)@

Returns a hash value for the given list. As noted above, if the list is of type OJF_UNIQUE, lists with the same cards in different order will hash the same. Non-unique lists will hash differently in this case.

h3. @int ojl_get(oj_cardlist_t *sp, int index)@<br>@int ojl_set(oj_cardlist_t *sp, int index, int card)@

Get and set the card at the given index. Will not change the size of the list.

h3. @int ojl_append(oj_cardlist_t *sp, int card)@

Adds a card to the end of the list if there is room, increasing its size by one.

h3. @int ojl_extend(oj_cardlist_t *destp, oj_cardlist_t *srcp, int count)@

Adds @count@ cards from the source list to the end of the destination list, increasing its size.

h3. @int ojl_insert(oj_cardlist_t *sp, int index, int card)@

Inserts a card at the given index, moving any following cards to make room, and increasing the size of the list by one.

h3. @int ojl_pop(oj_cardlist_t *sp)@

Remove and return one card from the end of the list. A common useful idiom for dealing a card from a deck stub to a hand or pile is this:

{% highlight cpp %}
    ojl_append(hand, ojl_pop(deck));
{% endhighlight %}

h3. @int ojl_delete(oj_cardlist_t *sp, int index)@

Remove the card at the given index.

h3. @int ojl_index(oj_cardlist_t *sp, int card)@

Returns the index at which the given card first appears in the list. If it is not present, returns OJE_NOTFOUND (which is -1).

h3. @int ojl_remove(oj_cardlist_t *sp, int card)@

Searches for the given card in the list, removing the the first one found, if present.

h3. @int ojl_copy(oj_cardlist_t *destp, oj_cardlist_t *srcp)@

Copies the source hand to the destination hand, overwriting whatever content it had previously.

h3. @int ojl_sort(oj_cardlist_t *sp)@

Sort the list in ascending order.

h3. @int ojl_reverse(oj_cardlist_t *sp)@

Reverse the order of cards in the list.

h3. @int ojl_equal(oj_cardlist_t *sp1, oj_cardlist_t *sp2)@

Compare two lists for equality. Returns true in the following cases: if _both_ lists are flagged @OJF_UNIQUE@ and they contain the same cards in any order, or if either list is not flagged, both lists must have exactly the same cards in the same order.

h3. @int ojl_fill(oj_cardlist_t *sp, int count, oj_deck_type_t dt)@

Fill a cardlist with @count@ from a standard deck type, overwriting any previous contents. the standard deck types are:

{% highlight cpp %}
    OJD_STANDARD            // Normal 52-card deck
    OJD_ONEJOKER            // 53 cards
    OJD_TWOJOKERS           // 54 cards
    OJD_STRIPPED32          // Remove 2..6 (Skat)
    OJD_STRIPPED40          // Remove 8,9,10 (Pan)
    OJD_STRIPPED40J         // (Mexican poker)
    OJD_PINOCHLE            // 24 cards, 9s and up
{% endhighlight %}

If @count@ is greater than the number of cards in the standard deck, they will be repeated. This can be used, for example, to fill a multi-deck blackjack shoe (or for games like Pinochle and Canasta).

h3. @int ojl_shuffle(oj_cardlist_t *sp)@

Properly randomize the list.

h3. @char *ojl_text(oj_cardlist_t *sp, char *buf, int size)@

Write into the given buffer a text representation of the list.
